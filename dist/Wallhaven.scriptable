{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "teal",
    "glyph" : "image"
  },
  "name" : "Wallhaven",
  "script" : "\/**\n * @version 1.0.0\n * @author Honye\n *\/\n\n\/**\n * å¤šè¯­è¨€å›½é™…åŒ–\n * @param {{[language: string]: string} | [en:string, zh:string]} langs\n *\/\nconst i18n = (langs) => {\n  const language = Device.language();\n  if (Array.isArray(langs)) {\n    langs = {\n      en: langs[0],\n      zh: langs[1],\n      others: langs[0]\n    };\n  } else {\n    langs.others = langs.others || langs.en;\n  }\n  return langs[language] || langs.others\n};\n\n\/**\n * è·å–ç½‘ç»œå›¾ç‰‡\n * @param {string} url\n *\/\nconst getImage = async (url) => {\n  const request = new Request(url);\n  const image = await request.loadImage();\n  return image\n};\n\n\/**\n * @param {...string} paths\n *\/\nconst joinPath = (...paths) => {\n  const fm = FileManager.local();\n  return paths.reduce((prev, curr) => {\n    return fm.joinPath(prev, curr)\n  }, '')\n};\n\n\/**\n * è§„èŒƒä½¿ç”¨ FileManagerã€‚æ¯ä¸ªè„šæœ¬ä½¿ç”¨ç‹¬ç«‹æ–‡ä»¶å¤¹\n *\n * æ³¨æ„ï¼šæ¡Œé¢ç»„ä»¶æ— æ³•å†™å…¥ cacheDirectory å’Œ temporaryDirectory\n * @param {object} options\n * @param {boolean} [options.useICloud]\n * @param {string} [options.basePath]\n *\/\nconst useFileManager = (options = {}) => {\n  const { useICloud, basePath } = options;\n  const fm = useICloud ? FileManager.iCloud() : FileManager.local();\n  const paths = [fm.documentsDirectory(), Script.name()];\n  if (basePath) {\n    paths.push(basePath);\n  }\n  const cacheDirectory = joinPath(...paths);\n  \/**\n   * åˆ é™¤è·¯å¾„æœ«å°¾æ‰€æœ‰çš„ \/\n   * @param {string} filePath\n   *\/\n  const safePath = (filePath) => {\n    return fm.joinPath(cacheDirectory, filePath).replace(\/\\\/+$\/, '')\n  };\n  \/**\n   * å¦‚æœä¸Šçº§æ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œåˆ™å…ˆåˆ›å»ºæ–‡ä»¶å¤¹\n   * @param {string} filePath\n   *\/\n  const preWrite = (filePath) => {\n    const i = filePath.lastIndexOf('\/');\n    const directory = filePath.substring(0, i);\n    if (!fm.fileExists(directory)) {\n      fm.createDirectory(directory, true);\n    }\n  };\n\n  const writeString = (filePath, content) => {\n    const nextPath = safePath(filePath);\n    preWrite(nextPath);\n    fm.writeString(nextPath, content);\n  };\n\n  \/**\n   * @param {string} filePath\n   * @param {*} jsonData\n   *\/\n  const writeJSON = (filePath, jsonData) => writeString(filePath, JSON.stringify(jsonData));\n  \/**\n   * @param {string} filePath\n   * @param {Image} image\n   *\/\n  const writeImage = (filePath, image) => {\n    const nextPath = safePath(filePath);\n    preWrite(nextPath);\n    return fm.writeImage(nextPath, image)\n  };\n\n  \/**\n   * æ–‡ä»¶ä¸å­˜åœ¨æ—¶è¿”å› null\n   * @param {string} filePath\n   * @returns {string|null}\n   *\/\n  const readString = (filePath) => {\n    const fullPath = fm.joinPath(cacheDirectory, filePath);\n    if (fm.fileExists(fullPath)) {\n      return fm.readString(\n        fm.joinPath(cacheDirectory, filePath)\n      )\n    }\n    return null\n  };\n\n  \/**\n   * @param {string} filePath\n   *\/\n  const readJSON = (filePath) => JSON.parse(readString(filePath));\n\n  \/**\n   * @param {string} filePath\n   *\/\n  const readImage = (filePath) => {\n    return fm.readImage(fm.joinPath(cacheDirectory, filePath))\n  };\n\n  return {\n    cacheDirectory,\n    writeString,\n    writeJSON,\n    writeImage,\n    readString,\n    readJSON,\n    readImage\n  }\n};\n\n\/** è§„èŒƒä½¿ç”¨æ–‡ä»¶ç¼“å­˜ã€‚æ¯ä¸ªè„šæœ¬ä½¿ç”¨ç‹¬ç«‹æ–‡ä»¶å¤¹ *\/\nconst useCache = () => useFileManager({ basePath: 'cache' });\n\n\/**\n * è½»æ¾å®ç°æ¡Œé¢ç»„ä»¶å¯è§†åŒ–é…ç½®\n *\n * - é¢œè‰²é€‰æ‹©å™¨åŠæ›´å¤šè¡¨å•æ§ä»¶\n * - å¿«é€Ÿé¢„è§ˆ\n *\n * GitHub: https:\/\/github.com\/honye\n *\n * @version 1.4.0\n * @author Honye\n *\/\nconst fm = FileManager.local();\nconst fileName = 'settings.json';\n\nconst toast = (message) => {\n  const notification = new Notification();\n  notification.title = Script.name();\n  notification.body = message;\n  notification.schedule();\n};\n\nconst isUseICloud = () => {\n  const ifm = useFileManager({ useICloud: true });\n  const filePath = fm.joinPath(ifm.cacheDirectory, fileName);\n  return fm.fileExists(filePath)\n};\n\n\/** æŸ¥çœ‹é…ç½®æ–‡ä»¶å¯å¯¼å‡ºåˆ†äº« *\/\nconst exportSettings = () => {\n  const scopedFM = useFileManager({ useICloud: isUseICloud() });\n  const filePath = fm.joinPath(scopedFM.cacheDirectory, fileName);\n  if (fm.isFileStoredIniCloud(filePath)) {\n    fm.downloadFileFromiCloud(filePath);\n  }\n  if (fm.fileExists(filePath)) {\n    QuickLook.present(filePath);\n  } else {\n    const alert = new Alert();\n    alert.message = i18n(['Using default configuration', 'ä½¿ç”¨çš„é»˜è®¤é…ç½®ï¼Œæœªåšä»»ä½•ä¿®æ”¹']);\n    alert.addCancelAction(i18n(['OK', 'å¥½çš„']));\n    alert.present();\n  }\n};\n\nconst importSettings = async () => {\n  const alert1 = new Alert();\n  alert1.message = i18n([\n    'Will replace existing configuration',\n    'ä¼šæ›¿æ¢å·²æœ‰é…ç½®ï¼Œç¡®è®¤å¯¼å…¥å—ï¼Ÿå¯å°†ç°æœ‰é…ç½®å¯¼å‡ºå¤‡ä»½åå†å¯¼å…¥å…¶ä»–é…ç½®'\n  ]);\n  alert1.addAction(i18n(['Import', 'å¯¼å…¥']));\n  alert1.addCancelAction(i18n(['Cancel', 'å–æ¶ˆ']));\n  const i = await alert1.present();\n  if (i === -1) return\n\n  const pathList = await DocumentPicker.open(['public.json']);\n  for (const path of pathList) {\n    const fileName = fm.fileName(path, true);\n    const scopedFM = useFileManager({ useICloud: isUseICloud() });\n    const destPath = fm.joinPath(scopedFM.cacheDirectory, fileName);\n    if (fm.fileExists(destPath)) {\n      fm.remove(destPath);\n    }\n    const i = destPath.lastIndexOf('\/');\n    const directory = destPath.substring(0, i);\n    if (!fm.fileExists(directory)) {\n      fm.createDirectory(directory, true);\n    }\n    fm.copy(path, destPath);\n  }\n  const alert = new Alert();\n  alert.message = i18n(['Imported success', 'å¯¼å…¥æˆåŠŸ']);\n  alert.addAction(i18n(['Restart', 'é‡æ–°è¿è¡Œ']));\n  await alert.present();\n  const callback = new CallbackURL('scriptable:\/\/\/run');\n  callback.addParameter('scriptName', Script.name());\n  callback.open();\n};\n\n\/**\n * @returns {Promise<Settings>}\n *\/\nconst readSettings = async () => {\n  const useICloud = isUseICloud();\n  console.log(`[info] use ${useICloud ? 'iCloud' : 'local'} settings`);\n  const fm = useFileManager({ useICloud });\n  const settings = fm.readJSON(fileName);\n  return settings\n};\n\n\/**\n * @param {Record<string, unknown>} data\n * @param {{ useICloud: boolean; }} options\n *\/\nconst writeSettings = async (data, { useICloud }) => {\n  const fm = useFileManager({ useICloud });\n  fm.writeJSON(fileName, data);\n};\n\nconst removeSettings = async (settings) => {\n  const cache = useFileManager({ useICloud: settings.useICloud });\n  fm.remove(\n    fm.joinPath(cache.cacheDirectory, fileName)\n  );\n};\n\nconst moveSettings = (useICloud, data) => {\n  const localFM = useFileManager();\n  const iCloudFM = useFileManager({ useICloud: true });\n  const [i, l] = [\n    fm.joinPath(iCloudFM.cacheDirectory, fileName),\n    fm.joinPath(localFM.cacheDirectory, fileName)\n  ];\n  try {\n    \/\/ ç§»åŠ¨æ–‡ä»¶éœ€è¦åˆ›å»ºçˆ¶æ–‡ä»¶å¤¹ï¼Œå†™å…¥æ“ä½œä¼šè‡ªåŠ¨åˆ›å»ºæ–‡ä»¶å¤¹\n    writeSettings(data, { useICloud });\n    if (useICloud) {\n      if (fm.fileExists(l)) fm.remove(l);\n    } else {\n      if (fm.fileExists(i)) fm.remove(i);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n};\n\n\/**\n * @typedef {object} NormalFormItem\n * @property {string} name\n * @property {string} label\n * @property {'text'|'number'|'color'|'select'|'date'|'cell'} [type]\n *  - HTML <input> type å±æ€§\n *  - `'cell'`: å¯ç‚¹å‡»çš„\n * @property {{ label: string; value: unknown }[]} [options]\n * @property {unknown} [default]\n *\/\n\/**\n * @typedef {Pick<NormalFormItem, 'label'|'name'> & { type: 'group', items: FormItem[] }} GroupFormItem\n *\/\n\/**\n * @typedef {Omit<NormalFormItem, 'type'> & { type: 'page' } & Pick<Options, 'formItems'|'onItemClick'>} PageFormItem å•ç‹¬çš„é¡µé¢\n *\/\n\/**\n * @typedef {NormalFormItem|GroupFormItem|PageFormItem} FormItem\n *\/\n\/**\n * @typedef {object} CommonSettings\n * @property {boolean} useICloud\n * @property {string} [backgroundImage] èƒŒæ™¯å›¾è·¯å¾„\n * @property {string} [backgroundColorLight]\n * @property {string} [backgroundColorDark]\n *\/\n\/**\n * @typedef {CommonSettings & Record<string, unknown>} Settings\n *\/\n\/**\n * @typedef {object} Options\n * @property {(data: {\n *  settings: Settings;\n *  family?: typeof config.widgetFamily;\n * }) => ListWidget | Promise<ListWidget>} render\n * @property {string} [head] é¡¶éƒ¨æ’å…¥ HTML\n * @property {FormItem[]} [formItems]\n * @property {(item: FormItem) => void} [onItemClick]\n * @property {string} [homePage] å³ä¸Šè§’åˆ†äº«èœå•åœ°å€\n * @property {(data: any) => void} [onWebEvent]\n *\/\n\/**\n * @template T\n * @typedef {T extends infer O ? {[K in keyof O]: O[K]} : never} Expand\n *\/\n\nconst previewsHTML =\n`<div class=\"actions\">\n  <button class=\"preview\" data-size=\"small\"><i class=\"iconfont icon-yingyongzhongxin\"><\/i>${i18n(['Small', 'é¢„è§ˆå°å·'])}<\/button>\n  <button class=\"preview\" data-size=\"medium\"><i class=\"iconfont icon-daliebiao\"><\/i>${i18n(['Medium', 'é¢„è§ˆä¸­å·'])}<\/button>\n  <button class=\"preview\" data-size=\"large\"><i class=\"iconfont icon-dantupailie\"><\/i>${i18n(['Large', 'é¢„è§ˆå¤§å·'])}<\/button>\n<\/div>`;\n\nconst copyrightHTML =\n`<footer>\n  <div class=\"copyright\">Â© UI powered by <a href=\"javascript:invoke('safari','https:\/\/www.imarkr.com');\">iMarkr<\/a>.<\/div>\n<\/footer>`;\n\n\/**\n * @param {Expand<Options>} options\n * @param {boolean} [isFirstPage]\n * @param {object} [others]\n * @param {Settings} [others.settings]\n * @returns {Promise<ListWidget|undefined>} ä»…åœ¨ Widget ä¸­è¿è¡Œæ—¶è¿”å› ListWidget\n *\/\nconst present = async (options, isFirstPage, others = {}) => {\n  const {\n    formItems = [],\n    onItemClick,\n    render,\n    head,\n    homePage = 'https:\/\/www.imarkr.com',\n    onWebEvent\n  } = options;\n  const cache = useCache();\n\n  const settings = others.settings || await readSettings() || {};\n\n  \/**\n   * @param {Parameters<Options['render']>[0]} param\n   *\/\n  const getWidget = async (param) => {\n    const widget = await render(param);\n    const { backgroundImage, backgroundColorLight, backgroundColorDark } = settings;\n    if (backgroundImage && fm.fileExists(backgroundImage)) {\n      widget.backgroundImage = fm.readImage(backgroundImage);\n    }\n    if (!widget.backgroundColor || backgroundColorLight || backgroundColorDark) {\n      widget.backgroundColor = Color.dynamic(\n        new Color(backgroundColorLight || '#ffffff'),\n        new Color(backgroundColorDark || '#242426')\n      );\n    }\n    return widget\n  };\n\n  if (config.runsInWidget) {\n    const widget = await getWidget({ settings });\n    Script.setWidget(widget);\n    return widget\n  }\n\n  \/\/ ====== web start =======\n  const style =\n`:root {\n  --color-primary: #007aff;\n  --divider-color: rgba(60,60,67,0.36);\n  --card-background: #fff;\n  --card-radius: 10px;\n  --list-header-color: rgba(60,60,67,0.6);\n}\n* {\n  -webkit-user-select: none;\n  user-select: none;\n}\nbody {\n  margin: 10px 0;\n  -webkit-font-smoothing: antialiased;\n  font-family: \"SF Pro Display\",\"SF Pro Icons\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",sans-serif;\n  accent-color: var(--color-primary);\n}\ninput {\n  -webkit-user-select: auto;\n  user-select: auto;\n}\nbody {\n  background: #f2f2f7;\n}\nbutton {\n  font-size: 16px;\n  background: var(--color-primary);\n  color: #fff;\n  border-radius: 8px;\n  border: none;\n  padding: 0.24em 0.5em;\n}\nbutton .iconfont {\n  margin-right: 6px;\n}\n.list {\n  margin: 15px;\n}\n.list__header {\n  margin: 0 20px;\n  color: var(--list-header-color);\n  font-size: 13px;\n}\n.list__body {\n  margin-top: 10px;\n  background: var(--card-background);\n  border-radius: var(--card-radius);\n  border-radius: 12px;\n  overflow: hidden;\n}\n.form-item {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 16px;\n  min-height: 2em;\n  padding: 0.5em 20px;\n  position: relative;\n}\n.form-item--link .icon-arrow_right {\n  color: #86868b;\n}\n.form-item + .form-item::before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 20px;\n  right: 0;\n  border-top: 0.5px solid var(--divider-color);\n}\n.form-item .iconfont {\n  margin-right: 4px;\n}\n.form-item input,\n.form-item select {\n  font-size: 14px;\n  text-align: right;\n}\n.form-item input[type=\"checkbox\"] {\n  width: 1.25em;\n  height: 1.25em;\n}\ninput[type=\"number\"] {\n  width: 4em;\n}\ninput[type=\"date\"] {\n  min-width: 6.4em;\n}\ninput[type='checkbox'][role='switch'] {\n  position: relative;\n  display: inline-block;\n  appearance: none;\n  width: 40px;\n  height: 24px;\n  border-radius: 24px;\n  background: #ccc;\n  transition: 0.3s ease-in-out;\n}\ninput[type='checkbox'][role='switch']::before {\n  content: '';\n  position: absolute;\n  left: 2px;\n  top: 2px;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: #fff;\n  transition: 0.3s ease-in-out;\n}\ninput[type='checkbox'][role='switch']:checked {\n  background: var(--color-primary);\n}\ninput[type='checkbox'][role='switch']:checked::before {\n  transform: translateX(16px);\n}\n.actions {\n  margin: 15px;\n}\n.copyright {\n  margin: 15px;\n  margin-inline: 18px;\n  font-size: 12px;\n  color: #86868b;\n}\n.copyright a {\n  color: #515154;\n  text-decoration: none;\n}\n.preview.loading {\n  pointer-events: none;\n}\n.icon-loading {\n  display: inline-block;\n  animation: 1s linear infinite spin;\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(1turn);\n  }\n}\n@media (prefers-color-scheme: dark) {\n  :root {\n    --divider-color: rgba(84,84,88,0.65);\n    --card-background: #1c1c1e;\n    --list-header-color: rgba(235,235,245,0.6);\n  }\n  body {\n    background: #000;\n    color: #fff;\n  }\n}\n`;\n\n  const js =\n`(() => {\n  const settings = ${JSON.stringify({\n    ...settings,\n    useICloud: isUseICloud()\n  })}\n  const formItems = ${JSON.stringify(formItems)}\n\n  window.invoke = (code, data) => {\n    window.dispatchEvent(\n      new CustomEvent(\n        'JBridge',\n        { detail: { code, data } }\n      )\n    )\n  }\n\n  const formData = {};\n\n  const createFormItem = (item) => {\n    const value = settings[item.name] ?? item.default ?? null\n    formData[item.name] = value;\n    const label = document.createElement(\"label\");\n    label.className = \"form-item\";\n    const div = document.createElement(\"div\");\n    div.innerText = item.label;\n    label.appendChild(div);\n    if (item.type === 'select') {\n      const select = document.createElement('select')\n      select.className = 'form-item__input'\n      select.name = item.name\n      select.value = value\n      for (const opt of (item.options || [])) {\n        const option = document.createElement('option')\n        option.value = opt.value\n        option.innerText = opt.label\n        option.selected = value === opt.value\n        select.appendChild(option)\n      }\n      select.addEventListener('change', (e) => {\n        formData[item.name] = e.target.value\n        invoke('changeSettings', formData)\n      })\n      label.appendChild(select)\n    } else if (\n      item.type === 'cell' ||\n      item.type === 'page'\n    ) {\n      label.classList.add('form-item--link')\n      const icon = document.createElement('i')\n      icon.className = 'iconfont icon-arrow_right'\n      label.appendChild(icon)\n      label.addEventListener('click', () => {\n        const { name } = item\n        switch (name) {\n          case 'backgroundImage':\n            invoke('chooseBgImg')\n            break\n          case 'clearBackgroundImage':\n            invoke('clearBgImg')\n            break\n          case 'reset':\n            reset()\n            break\n          default:\n            invoke('itemClick', item)\n        }\n      })\n    } else {\n      const input = document.createElement(\"input\")\n      input.className = 'form-item__input'\n      input.name = item.name\n      input.type = item.type || \"text\";\n      input.enterKeyHint = 'done'\n      input.value = value\n      \/\/ Switch\n      if (item.type === 'switch') {\n        input.type = 'checkbox'\n        input.role = 'switch'\n        input.checked = value\n        if (item.name === 'useICloud') {\n          input.addEventListener('change', (e) => {\n            invoke('moveSettings', e.target.checked)\n          })\n        }\n      }\n      if (item.type === 'number') {\n        input.inputMode = 'decimal'\n      }\n      if (input.type === 'text') {\n        input.size = 12\n      }\n      input.addEventListener(\"change\", (e) => {\n        formData[item.name] =\n          item.type === 'switch'\n          ? e.target.checked\n          : item.type === 'number'\n          ? Number(e.target.value)\n          : e.target.value;\n        invoke('changeSettings', formData)\n      });\n      label.appendChild(input);\n    }\n    return label\n  }\n\n  const createList = (list, title) => {\n    const fragment = document.createDocumentFragment()\n\n    let elBody;\n    for (const item of list) {\n      if (item.type === 'group') {\n        const grouped = createList(item.items, item.label)\n        fragment.appendChild(grouped)\n      } else {\n        if (!elBody) {\n          const groupDiv = fragment.appendChild(document.createElement('div'))\n          groupDiv.className = 'list'\n          if (title) {\n            const elTitle = groupDiv.appendChild(document.createElement('div'))\n            elTitle.className = 'list__header'\n            elTitle.textContent = title\n          }\n          elBody = groupDiv.appendChild(document.createElement('div'))\n          elBody.className = 'list__body'\n        }\n        const label = createFormItem(item)\n        elBody.appendChild(label)\n      }\n    }\n    return fragment\n  }\n\n  const fragment = createList(formItems)\n  document.getElementById('settings').appendChild(fragment)\n\n  for (const btn of document.querySelectorAll('.preview')) {\n    btn.addEventListener('click', (e) => {\n      const target = e.currentTarget\n      target.classList.add('loading')\n      const icon = e.currentTarget.querySelector('.iconfont')\n      const className = icon.className\n      icon.className = 'iconfont icon-loading'\n      const listener = (event) => {\n        const { code } = event.detail\n        if (code === 'previewStart') {\n          target.classList.remove('loading')\n          icon.className = className\n          window.removeEventListener('JWeb', listener);\n        }\n      }\n      window.addEventListener('JWeb', listener)\n      invoke('preview', e.currentTarget.dataset.size)\n    })\n  }\n\n  const setFieldValue = (name, value) => {\n    const input = document.querySelector(\\`.form-item__input[name=\"\\${name}\"]\\`)\n    if (!input) return\n    if (input.type === 'checkbox') {\n      input.checked = value\n    } else {\n      input.value = value\n    }\n  }\n\n  const reset = (items = formItems) => {\n    for (const item of items) {\n      if (item.type === 'group') {\n        reset(item.items)\n      } else if (item.type === 'page') {\n        continue;\n      } else {\n        setFieldValue(item.name, item.default)\n      }\n    }\n    invoke('removeSettings', formData)\n  }\n})()`;\n\n  const html =\n`<html>\n  <head>\n    <meta name='viewport' content='width=device-width, user-scalable=no'>\n    <link rel=\"stylesheet\" href=\"\/\/at.alicdn.com\/t\/c\/font_3772663_kmo790s3yfq.css\" type=\"text\/css\">\n    <style>${style}<\/style>\n  <\/head>\n  <body>\n  ${head || ''}\n  <section id=\"settings\"><\/section>\n  ${isFirstPage ? (previewsHTML + copyrightHTML) : ''}\n  <script>${js}<\/script>\n  <\/body>\n<\/html>`;\n\n  const webView = new WebView();\n  await webView.loadHTML(html, homePage);\n\n  const clearBgImg = () => {\n    const { backgroundImage } = settings;\n    delete settings.backgroundImage;\n    if (backgroundImage && fm.fileExists(backgroundImage)) {\n      fm.remove(backgroundImage);\n    }\n    writeSettings(settings, { useICloud: settings.useICloud });\n    toast(i18n(['Cleared success!', 'èƒŒæ™¯å·²æ¸…é™¤']));\n  };\n\n  const chooseBgImg = async () => {\n    try {\n      const image = await Photos.fromLibrary();\n      cache.writeImage('bg.png', image);\n      const imgPath = fm.joinPath(cache.cacheDirectory, 'bg.png');\n      settings.backgroundImage = imgPath;\n      writeSettings(settings, { useICloud: settings.useICloud });\n    } catch (e) {\n      console.log('[info] ç”¨æˆ·å–æ¶ˆé€‰æ‹©å›¾ç‰‡');\n    }\n  };\n\n  const injectListener = async () => {\n    const event = await webView.evaluateJavaScript(\n      `(() => {\n        const controller = new AbortController()\n        const listener = (e) => {\n          completion(e.detail)\n          controller.abort()\n        }\n        window.addEventListener(\n          'JBridge',\n          listener,\n          { signal: controller.signal }\n        )\n      })()`,\n      true\n    ).catch((err) => {\n      console.error(err);\n      throw err\n    });\n    const { code, data } = event;\n    switch (code) {\n      case 'preview': {\n        const widget = await getWidget({ settings, family: data });\n        webView.evaluateJavaScript(\n          'window.dispatchEvent(new CustomEvent(\\'JWeb\\', { detail: { code: \\'previewStart\\' } }))',\n          false\n        );\n        widget[`present${data.replace(data[0], data[0].toUpperCase())}`]();\n        break\n      }\n      case 'safari':\n        Safari.openInApp(data, true);\n        break\n      case 'changeSettings':\n        Object.assign(settings, data);\n        writeSettings(settings, { useICloud: settings.useICloud });\n        break\n      case 'moveSettings':\n        settings.useICloud = data;\n        moveSettings(data, settings);\n        break\n      case 'removeSettings':\n        Object.assign(settings, data);\n        clearBgImg();\n        removeSettings(settings);\n        break\n      case 'chooseBgImg':\n        chooseBgImg();\n        break\n      case 'clearBgImg':\n        clearBgImg();\n        break\n      case 'itemClick':\n        if (data.type === 'page') {\n          \/\/ `data` ç»ä¼ åˆ° HTML åä¸¢å¤±äº†ä¸å¯åºåˆ—åŒ–çš„æ•°æ®ï¼Œå› ä¸ºéœ€è¦ä»æºæ•°æ®æŸ¥æ‰¾\n          const item = (() => {\n            const find = (items) => {\n              for (const el of items) {\n                if (el.name === data.name) return el\n\n                if (el.type === 'group') {\n                  const r = find(el.items);\n                  if (r) return r\n                }\n              }\n              return null\n            };\n            return find(formItems)\n          })();\n          await present(item, false, { settings });\n        } else {\n          await onItemClick?.(data, { settings });\n        }\n        break\n      case 'native':\n        onWebEvent?.(data);\n        break\n    }\n    injectListener();\n  };\n\n  injectListener().catch((e) => {\n    console.error(e);\n    throw e\n  });\n  webView.present();\n  \/\/ ======= web end =========\n};\n\n\/**\n * @param {Options} options\n *\/\nconst withSettings = async (options) => {\n  const { formItems, onItemClick, ...restOptions } = options;\n  return present({\n    formItems: [\n      {\n        label: i18n(['Common', 'é€šç”¨']),\n        type: 'group',\n        items: [\n          {\n            label: i18n(['Sync with iCloud', 'iCloud åŒæ­¥']),\n            type: 'switch',\n            name: 'useICloud',\n            default: false\n          },\n          {\n            label: i18n(['Background', 'èƒŒæ™¯']),\n            type: 'page',\n            name: 'background',\n            formItems: [\n              {\n                label: i18n(['Background', 'èƒŒæ™¯']),\n                type: 'group',\n                items: [\n                  {\n                    name: 'backgroundColorLight',\n                    type: 'color',\n                    label: i18n(['Background color (light)', 'èƒŒæ™¯è‰²ï¼ˆç™½å¤©ï¼‰']),\n                    default: '#ffffff'\n                  },\n                  {\n                    name: 'backgroundColorDark',\n                    type: 'color',\n                    label: i18n(['Background color (dark)', 'èƒŒæ™¯è‰²ï¼ˆå¤œé—´ï¼‰']),\n                    default: '#242426'\n                  },\n                  {\n                    label: i18n(['Background image', 'èƒŒæ™¯å›¾']),\n                    type: 'cell',\n                    name: 'backgroundImage'\n                  }\n                ]\n              },\n              {\n                type: 'group',\n                items: [\n                  {\n                    label: i18n(['Clear background image', 'æ¸…é™¤èƒŒæ™¯å›¾']),\n                    type: 'cell',\n                    name: 'clearBackgroundImage'\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            label: i18n(['Reset', 'é‡ç½®']),\n            type: 'cell',\n            name: 'reset'\n          }\n        ]\n      },\n      {\n        type: 'group',\n        items: [\n          {\n            label: i18n(['Export settings', 'å¯¼å‡ºé…ç½®']),\n            type: 'cell',\n            name: 'export'\n          },\n          {\n            label: i18n(['Import settings', 'å¯¼å…¥é…ç½®']),\n            type: 'cell',\n            name: 'import'\n          }\n        ]\n      },\n      {\n        label: i18n(['Settings', 'è®¾ç½®']),\n        type: 'group',\n        items: formItems\n      }\n    ],\n    onItemClick: (item, ...args) => {\n      const { name } = item;\n      if (name === 'export') {\n        exportSettings();\n      }\n      if (name === 'import') {\n        importSettings().catch((err) => {\n          console.error(err);\n          throw err\n        });\n      }\n      onItemClick?.(item, ...args);\n    },\n    ...restOptions\n  }, true)\n};\n\nconst preference = {\n  categories: '010',\n  sorting: 'date_added',\n  colors: '',\n  purity: '100',\n  count: '1',\n  gap: '4',\n  borderWidth: '0',\n  cornerRadius: '0',\n  itemCornerRadius: '0',\n  apikey: ''\n};\n\nconst getWallpapers = async () => {\n  const params = {\n    q: preference.q,\n    categories: preference.categories,\n    sorting: preference.sorting,\n    colors: preference.colors,\n    purity: preference.purity,\n    apikey: preference.apikey\n  };\n  let search = [];\n  for (const k in params) {\n    const v = preference[k];\n    if (v) {\n      search.push(`${k}=${encodeURIComponent(v)}`);\n    }\n  }\n  search = search.join('&');\n  const api = 'https:\/\/wallhaven.cc\/api\/v1\/search';\n  const url = `${api}?${search}`;\n  const request = new Request(url);\n  const json = await request.loadJSON();\n  return json\n};\n\nconst addItem = async (widget, data) => {\n  const { itemCornerRadius } = preference;\n  const wrapper = widget.addStack();\n  wrapper.url = data.url;\n  const imageStack = wrapper.addStack();\n  imageStack.cornerRadius = Number(itemCornerRadius);\n  imageStack.layoutVertically();\n  imageStack.addSpacer();\n  imageStack.addStack().addSpacer();\n  const image = await getImage(data.path);\n  imageStack.backgroundImage = image;\n};\n\nconst addOne = async (widget, data) => {\n  const { cornerRadius } = preference;\n  const item = widget.addStack();\n  item.cornerRadius = Number(cornerRadius);\n  await addItem(item, data);\n};\n\nconst addTwo = async (widget, data) => {\n  const { cornerRadius, gap } = preference;\n  const stack = widget.addStack();\n  stack.cornerRadius = Number(cornerRadius);\n  for (const [i, item] of data.entries()) {\n    if (i > 0) {\n      stack.addSpacer(Number(gap));\n    }\n    await addItem(stack, item);\n  }\n};\n\nconst addThree = async (widget, data) => {\n  const { cornerRadius, gap } = preference;\n  const stack = widget.addStack();\n  stack.cornerRadius = Number(cornerRadius);\n  await addItem(stack, data[0]);\n  stack.addSpacer(Number(gap));\n  const right = stack.addStack();\n  right.layoutVertically();\n  right.addStack().addSpacer();\n  for (const [i, item] of data.slice(1).entries()) {\n    if (i > 0) {\n      right.addSpacer(Number(gap));\n    }\n    await addItem(right, item);\n  }\n};\n\nconst addFour = async (widget, data) => {\n  const { cornerRadius, gap } = preference;\n  const stack = widget.addStack();\n  stack.cornerRadius = Number(cornerRadius);\n  for (let i = 0; i < 2; i++) {\n    if (i > 0) {\n      stack.addSpacer(Number(gap));\n    }\n    const half = stack.addStack();\n    half.layoutVertically();\n    for (const [j, item] of data.slice(i * 2, i * 2 + 2).entries()) {\n      if (j > 0) {\n        half.addSpacer(Number(gap));\n      }\n      log(`${i}-${j}`);\n      await addItem(half, item);\n    }\n  }\n};\n\nconst createWidget = async () => {\n  const { borderWidth, count, purity, apikey } = preference;\n  const family = config.widgetFamily;\n  const widget = new ListWidget();\n  widget.setPadding(...Array(4).fill(Number(borderWidth)));\n  if (purity === '001' && !apikey) {\n    const text = widget.addText(\n      i18n(['\"NSFW\" need API Key', 'â€œå‚æ¶è‹¥æ¸´â€éœ€è¦ API Key'])\n    );\n    text.centerAlignText();\n    text.textColor = Color.red();\n    return widget\n  }\n\n  const { data } = await getWallpapers();\n  if (!data.length) {\n    const text = widget.addText(i18n(['Not match was found', 'æœªå‘ç°åŒ¹é…é¡¹ç›®']));\n    text.centerAlignText();\n    text.textColor = Color.red();\n    return widget\n  }\n\n  if (family === 'small') {\n    widget.url = count > 1\n      ? 'https:\/\/wallhaven.cc\/'\n      : data[0].url;\n  }\n  const n = Math.min(count, data.length);\n  if (n === 1) {\n    await addOne(widget, data[0]);\n  } else if (n === 2) {\n    await addTwo(widget, data.slice(0, 2));\n  } else if (n === 3) {\n    await addThree(widget, data.slice(0, 3));\n  } else if (n === 4) {\n    await addFour(widget, data.slice(0, 4));\n  }\n\n  return widget\n};\n\nawait withSettings({\n  formItems: [\n    {\n      label: i18n(['Search', 'æœç´¢']),\n      name: 'q',\n      type: 'text',\n      default: ''\n    },\n    {\n      label: i18n(['Categories', 'åˆ†ç±»']),\n      name: 'categories',\n      type: 'select',\n      options: [\n        { label: i18n(['All', 'å…¨éƒ¨']), value: '111' },\n        { label: i18n(['General', 'æ™®éçš„']), value: '100' },\n        { label: i18n(['Anime', 'åŠ¨æ¼«']), value: '010' },\n        { label: i18n(['People', 'çœŸäºº']), value: '001' }\n      ],\n      default: preference.categories\n    },\n    {\n      label: i18n(['Sorting', 'æ’åº']),\n      name: 'sorting',\n      type: 'select',\n      options: [\n        { label: i18n(['Date added', 'ä¸Šä¼ æ—¶é—´']), value: 'date_added' },\n        { label: i18n(['Relevance', 'ç›¸å…³æ€§']), value: 'relevance' },\n        { label: i18n(['Random', 'éšæœº']), value: 'random' },\n        { label: i18n(['Views', 'æµè§ˆé‡']), value: 'views' },\n        { label: i18n(['Favorites', 'æ”¶è—é‡']), value: 'favorites' },\n        { label: i18n(['Toplist', 'æ¦œå•']), value: 'toplist' }\n      ],\n      default: preference.sorting\n    },\n    {\n      label: i18n(['Colors', 'è‰²å½©']),\n      name: 'colors',\n      type: 'select',\n      options: [\n        { label: i18n(['ğŸ”˜ All', 'ğŸ”˜ å…¨éƒ¨']), value: '' },\n        { label: i18n(['ğŸ”´ red', 'ğŸ”´ çº¢è‰²']), value: 'cc0000' },\n        { label: i18n(['ğŸŸ£ purple', 'ğŸŸ£ ç´«è‰²']), value: '993399' },\n        { label: i18n(['ğŸ”µ blue', 'ğŸ”µ è“è‰²']), value: '0066cc' },\n        { label: i18n(['ğŸŸ¢ green', 'ğŸŸ¢ ç»¿è‰²']), value: '77cc33' },\n        { label: i18n(['ğŸŸ¡ yellow', 'ğŸŸ¡ é»„è‰²']), value: 'ffff00' },\n        { label: i18n(['ğŸŸ¤ brown', 'ğŸŸ¤ æ£•è‰²']), value: '663300' },\n        { label: i18n(['ğŸŸ  orange', 'ğŸŸ  æ©™è‰²']), value: 'ff6600' },\n        { label: i18n(['âš«ï¸ black', 'âš«ï¸ é»‘è‰²']), value: '000000' },\n        { label: i18n(['âšªï¸ white', 'âšªï¸ ç™½è‰²']), value: 'ffffff' }\n      ],\n      default: preference.colors\n    },\n    {\n      label: i18n(['Purity', 'çº¯å‡€æ¨¡å¼']),\n      name: 'purity',\n      type: 'select',\n      options: [\n        { label: i18n(['SFW', 'å¿ƒå¹³å¦‚æ°´']), value: '100' },\n        { label: i18n(['Sketchy', 'è‹¥éšè‹¥ç°']), value: '010' },\n        { label: i18n(['NSFW', 'å‚æ¶è‹¥æ¸´']), value: '001' }\n      ],\n      default: preference.purity\n    },\n    {\n      label: i18n(['Count', 'æ˜¾ç¤ºæ•°é‡']),\n      name: 'count',\n      type: 'select',\n      options: [\n        { label: '1', value: '1' },\n        { label: '2', value: '2' },\n        { label: '3', value: '3' },\n        { label: '4', value: '4' }\n      ],\n      default: 1\n    },\n    {\n      label: i18n(['Gap size', 'é—´éš™å¤§å°']),\n      name: 'gap',\n      type: 'number',\n      default: '4'\n    },\n    {\n      label: i18n(['Border width', 'è¾¹æ¡†å®½åº¦']),\n      name: 'borderWidth',\n      type: 'number',\n      default: '0'\n    },\n    {\n      label: i18n(['Corner radius', 'åœ†è§’']),\n      name: 'cornerRadius',\n      type: 'number',\n      default: '0'\n    },\n    {\n      label: i18n(['Item corner radius', 'æ¯é¡¹åœ†è§’']),\n      name: 'itemCornerRadius',\n      type: 'number',\n      default: '0'\n    },\n    {\n      label: 'API Key',\n      name: 'apikey',\n      type: 'text',\n      default: ''\n    }\n  ],\n  render: async ({ settings }) => {\n    Object.assign(preference, settings);\n    const widget = await createWidget();\n    return widget\n  }\n});\n",
  "share_sheet_inputs" : [

  ]
}